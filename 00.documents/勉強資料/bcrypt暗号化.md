## [bcrypt 暗号化ロジックの説明] (JP)

`bcrypt`は、パスワードを安全に保存するために設計された強力なハッシュ関数です。ユーザー登録時にクライアントから受け取ったパスワードをデータベースに保存する前に、必ず`bcrypt`を使用して暗号化（ハッシュ化）する必要があります。

`bcrypt`の暗号化ロジックが**一般的なハッシュ関数よりもはるかに安全**である理由を、コアな概念を中心に説明します。

---

### 1. 🔍 ハッシュ関数とは何か？

ハッシュ関数は、任意の長さのデータを入力として受け取り、**固定長のデータ**に変換する関数です。

* **一方向性 (One-way):** ハッシュ化された値（ダイジェスト）を、元の入力値（パスワード）に戻すことはできません。（復号化不可能）
* **一貫性:** 同じ入力に対しては、常に同じ出力が保証されます。

**一般的なハッシュ関数の問題点:**
`MD5`や`SHA-256`のような一般的なハッシュ関数は非常に高速です。この速度が、**総当たり攻撃 (Brute-Force Attack)** や **レインボーテーブル攻撃 (Rainbow Table Attack)** に対する脆弱性につながります。攻撃者がデータベースからハッシュ化された値を盗み出した場合、非常に速い速度で何百億ものパスワードを試行し、元のパスワードを特定できてしまう可能性があります。

---

### 2. 🛡️ bcryptの3つの主要な安全要素 

`bcrypt`は、一般的なハッシュ関数の弱点を補うために、以下の3つの主要な要素を統合しています。

#### 1. Salt (ソルト)

* **役割:** **ランダムに生成されたデータ**をパスワードと混ぜてハッシュ化することです。
* **動作:**
    * ユーザーAが「password123」を入力します。
    * `bcrypt`は、例えば「XYZ」というランダムなソルトを生成します。
    * 実際のハッシュ化処理は、`Hash('password123' + 'XYZ')`のように行われます。
* **安全性への貢献:** ソルトを使用すると、**同じパスワードを持つすべてのユーザーが完全に異なるハッシュ値**を持つことになります。これにより、レインボーテーブル攻撃が根本的に不可能になります。

#### 2. Work Factor (作業係数) / Rounds (ラウンド)

* **役割:** ハッシュ化を実行する**反復回数（ラウンド）**を調整することで、ハッシュ化の速度を**意図的に遅くします**。
* **動作:**
    * 反復回数（ラウンド） `SALT_ROUNDS = 10` は、`2^10 = 1024回`のハッシュ演算を実行することを意味します。
    * 反復回数（Work Factor）が高いほど、暗号化にかかる時間は長くなりますが、攻撃者がハッシュを破るのに必要な時間は**指数関数的に**増加します。
* **安全性への貢献:** サーバーでハッシュを計算するのに1秒かかる場合、攻撃者が総当たり攻撃を行う際にもパスワード1つを確認するのに1秒かかるため、現実的にパスワードを解読することは不可能になります。

#### 3. Output Format (出力形式)

`bcrypt`は、最終的なハッシュ値に**ソルトと作業係数の情報を一緒に含めて**保存します。
```
$2a$10$XXXXXXXXXXXXXXXXXXXXXX/YYYYYYYYYYYYYYYYYYYYYYYYYYY
 |  |  |                     |
 |  |  |                     └─ 実際のパスワードのハッシュ値
 |  |  └─ ランダムなソルト値
 |  └─ 作業係数 (Work Factor, 10)
 └─ bcryptのバージョン
```

このようにソルトと作業係数がハッシュ値に含まれているため、データベースに**このハッシュ値一つだけを保存**しても、後にパスワードを検証する際に必要なすべての情報を`bcrypt`が自動的に読み取って処理することができます。

---

### 3. 📝 ログイン時のパスワード検証ロジック

ユーザーがログイン時に入力したパスワードを検証する際は、`bcrypt.compare()`関数を使用します。

```typescript
// ユーザーが入力した平文パスワード (data.password) と
// DBに保存されているハッシュ値 (savedUser.password) を比較します。
const isMatch = await bcrypt.compare(data.password, savedUser.password);

if (isMatch) {
    // ログイン成功
} else {
    // ログイン失敗
}
```

`bcrypt.compare()`関数は、ハッシュ値からソルトと作業係数を抽出して、入力されたパスワードを**同じソルトと作業係数で再度ハッシュ化**した後、保存されているハッシュ値と一致するかどうかを比較します。

これが`bcrypt`が強力なセキュリティを提供するコアなロジックです。

<br><br>

### 🛑 参考: パスワードハッシュに対する主な攻撃タイプ

パスワードハッシュを回避または解読しようとする主な攻撃方式は以下の通りです。

#### 1. 総当たり攻撃 (Brute-Force Attack)

| 項目 | 内容 |
| :--- | :--- |
| **概念** | **あり得るすべての文字列の組み合わせ**を生成し、ハッシュ化されたパスワードと比較する方式です。 |
| **攻撃プロセス** | 攻撃者は「a」「b」「c」「aa」「ab」...「password123」など、考えられるすべてのパスワードを推測し、それぞれの推測値のハッシュを計算して、盗み出したハッシュ値と一致するかどうかを確認します。 |
| **脆弱性** | **ハッシュ関数の計算速度が速いほど**、攻撃者は1秒あたり数十億回の試行を行うことができ、攻撃成功の確率が高まります。 |
| **bcryptによる防御** | **Work Factor (作業係数)** の設定により、ハッシュの速度を意図的に遅くします。攻撃者がパスワード一つを確認するのに多大な時間がかかるようにすることで、実質的に攻撃を不可能にします。 |

#### 2. レインボーテーブル攻撃 (Rainbow Table Attack)

| 項目 | 内容 |
| :--- | :--- |
| **概念** | **事前に計算された膨大な量のハッシュ値と元のパスワードのペア**（テーブル）を利用して、ハッシュ値を検索する方式です。 |
| **攻撃プロセス** | 攻撃者は盗み出したハッシュ値をテーブルですばやく検索します。ハッシュ値がテーブルに存在すれば、その横に記録されている元のパスワードを即座に入手できます。 |
| **脆弱性** | **ソルト(Salt)を使用していない**場合、世界中の多くのユーザーが「123456」という同じパスワードを使用していてもハッシュ値が同一になるため、たった一度のハッシュ計算で全ユーザーのパスワードを同時に解読できてしまいます。 |
| **bcryptによる防御** | **Salt (ソルト)** を使用して、**同じパスワードであってもユーザーごとに完全に異なるハッシュ値**を生成します。攻撃者が事前にハッシュテーブルを作成することを不可能にすることで、この攻撃を根本的に阻止します。 |

<br><br><br><br>

## [bcrypt 암호화 로직 설명] (KR)

`bcrypt`는 비밀번호를 안전하게 저장하기 위해 설계된 강력한 해시 함수입니다. 사용자 가입 시 클라이언트로부터 받은 비밀번호를 데이터베이스에 저장하기 전에, 반드시 `bcrypt`를 사용하여 암호화(해시)해야 합니다.

`bcrypt`의 암호화 로직이 **일반적인 해시 함수보다 훨씬 안전**한 이유를 핵심 개념을 중심으로 설명해 드리겠습니다.

---

### 1. 🔍 해시 함수란 무엇인가?

해시 함수는 임의의 길이의 데이터를 입력받아 **고정된 길이의 데이터**로 변환하는 함수입니다.

* **단방향성 (One-way):** 해시된 값(다이제스트)을 다시 원래의 입력값(비밀번호)으로 되돌릴 수 없습니다. (복호화 불가능)
* **일관성:** 동일한 입력에 대해서는 항상 동일한 출력을 보장합니다.

**일반적인 해시 함수의 문제점:**
`MD5`나 `SHA-256` 같은 일반적인 해시 함수는 매우 빠릅니다. 이 속도는 **무차별 대입 공격 (Brute-Force Attack)** 이나 **레인보우 테이블 공격 (Rainbow Table Attack)** 에 대한 취약점으로 이어집니다. 공격자가 해시된 DB 값을 탈취하면, 아주 빠른 속도로 수백억 개의 비밀번호를 대입해 원래 비밀번호를 찾아낼 수 있습니다.

---

### 2. 🛡️ bcrypt의 3가지 핵심 안전 요소 

`bcrypt`는 일반적인 해시 함수의 취약점을 보완하기 위해 세 가지 핵심 요소를 통합했습니다.

#### 1. Salt (솔트)

* **역할:** **랜덤하게 생성된 데이터**를 비밀번호와 섞어서 해시하는 것입니다.
* **동작:**
    * 사용자 A가 'password123'을 입력합니다.
    * `bcrypt`는 예를 들어 'XYZ'라는 랜덤 솔트를 생성합니다.
    * 실제 해시 작업은 `Hash('password123' + 'XYZ')`와 같이 이루어집니다.
* **안전성 기여:** 솔트를 사용하면 **같은 비밀번호를 가진 모든 사용자가 완전히 다른 해시 값**을 갖게 됩니다. 이로 인해 레인보우 테이블 공격이 원천적으로 불가능해집니다.

#### 2. Work Factor (작업 계수) / Rounds (라운드)

* **역할:** 해시 작업을 수행하는 **반복 횟수(라운드)** 를 조절하여 해시 속도를 **일부러 늦춥니다.**
* **동작:**
    * 반복 횟수(라운드) `SALT_ROUNDS = 10`은 `2^10 = 1024번`의 해시 연산을 수행하라는 의미입니다.
    * 반복 횟수(Work Factor)가 높을수록 암호화에는 시간이 더 걸리지만, 공격자가 해시를 깨는 데 필요한 시간은 **기하급수적으로** 늘어납니다.
* **안전성 기여:** 서버에서 해시를 계산하는 데 1초가 걸린다면, 공격자는 무차별 대입 공격을 할 때도 비밀번호 하나를 확인하는 데 1초가 걸리므로, 현실적으로 비밀번호를 알아내는 것이 불가능해집니다.

#### 3. Output Format (결과 형식)

`bcrypt`는 최종 해시 값에 **솔트와 작업 계수 정보를 함께 포함**하여 저장합니다.
```
$2a$10$XXXXXXXXXXXXXXXXXXXXXX/YYYYYYYYYYYYYYYYYYYYYYYYYYY
 |  |  |                     |
 |  |  |                     └─ 실제 비밀번호 해시 값
 |  |  └─ 랜덤 솔트 값
 |  └─ 작업 계수 (Work Factor, 10)
 └─ bcrypt 버전
```
이렇게 솔트와 작업 계수가 해시 값에 포함되어 있으므로, DB에 **오직 이 해시 값 하나만 저장**해도 나중에 비밀번호를 검증할 때 필요한 모든 정보를 `bcrypt`가 알아서 읽고 처리할 수 있습니다.

---

### 3. 📝 로그인 시 비밀번호 검증 로직

사용자가 로그인 시 입력한 비밀번호를 검증할 때는 `bcrypt.compare()` 함수를 사용합니다.

```typescript
// 사용자가 입력한 평문 비밀번호 (data.password)와
// DB에 저장된 해시 값 (savedUser.password)을 비교합니다.
const isMatch = await bcrypt.compare(data.password, savedUser.password);

if (isMatch) {
    // 로그인 성공
} else {
    // 로그인 실패
}
```

`bcrypt.compare()` 함수는 해시 값에서 솔트와 작업 계수를 추출하여, 입력된 비밀번호를 **동일한 솔트와 작업 계수로 다시 해시한 후** 저장된 해시 값과 일치하는지 비교합니다.

이것이 `bcrypt`가 강력한 보안을 제공하는 핵심 로직입니다.

<br><br>

### 🛑 참고: 비밀번호 해시에 대한 주요 공격 유형

비밀번호 해시를 우회하거나 해독하려는 주요 공격 방식은 다음과 같습니다.

#### 1. 무차별 대입 공격 (Brute-Force Attack)

| 항목 | 내용 |
| :--- | :--- |
| **개념** | **가능한 모든 문자열 조합**을 생성하여 해시된 비밀번호와 비교하는 방식입니다. |
| **공격 과정** | 공격자는 'a', 'b', 'c', 'aa', 'ab', ... 'password123' 등 가능한 모든 비밀번호를 추측하여, 각 추측값의 해시를 계산한 후 탈취한 해시 값과 일치하는지 확인합니다. |
| **취약점** | **해시 함수의 계산 속도가 빠를수록** 공격자는 초당 수십억 개의 비밀시도를 할 수 있어 공격 성공 확률이 높아집니다. |
| **bcrypt의 방어** | **Work Factor (작업 계수)** 설정을 통해 해시 속도를 의도적으로 늦춥니다. 공격자가 비밀번호 하나를 확인하는 데 많은 시간이 걸리게 하여, 현실적으로 공격을 불가능하게 만듭니다. |

#### 2. 레인보우 테이블 공격 (Rainbow Table Attack)

| 항목 | 내용 |
| :--- | :--- |
| **개념** | **미리 계산된 방대한 양의 해시 값과 원본 비밀번호 쌍** (테이블)을 이용하여 해시 값을 검색하는 방식입니다. |
| **공격 과정** | 공격자는 탈취한 해시 값을 테이블에서 빠르게 찾습니다. 해시 값이 테이블에 존재하면, 그 옆에 기록된 원본 비밀번호를 즉시 얻어낼 수 있습니다. |
| **취약점** | **솔트(Salt)를 사용하지 않은** 경우, 전 세계 수많은 사용자가 '123456'이라는 같은 비밀번호를 사용해도 해시 값이 동일하므로, 단 한 번의 해시 계산으로 모든 사용자의 비밀번호를 동시에 해독할 수 있습니다. |
| **bcrypt의 방어** | **Salt (솔트)** 를 사용하여 **같은 비밀번호라도 사용자마다 완전히 다른 해시 값**을 생성합니다. 공격자가 미리 해시 테이블을 만드는 것을 불가능하게 만들어 이 공격을 원천 차단합니다. |